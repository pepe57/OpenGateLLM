---
slug: 0.4.0-release-note
title: 0.4.0 - Release note
authors: [leoguillaume]
tags: [RAG, Elasticsearch]
---

:::warning
Version 0.4.0 is not yet available in its stable release, with minor modifications still under development.
:::

With the release of OpenGateLLM version 0.4.0 (previous version 0.3.7), we have decided to revise our approach based on Elasticsearch's recommended best practices. The main changes are as follows:
* Deprecation of Qdrant support in favor of Elasticsearch
* Consolidation of Elasticsearch indices into a single index
* Convert document metadata into a single field with constraints

These major changes require a data migration of your vector store. We provide a migration script here to help you update your instance.

<!-- truncate -->

## Introduction

Currently, we support two vector store technologies: Qdrant and Elasticsearch. A few months ago, we decided to focus on Elasticsearch for managing our document collections. We revisit the reasons for this choice here.

However, over the past few weeks, we have encountered scalability issues with Elasticsearch. These problems stem from how we implemented Elasticsearch in OpenGateLLM. To resolve these issues, we decided to revise our approach, which involves major changes and a data migration.

To this end, we detail the modifications we have made and provide a migration script to help you update your instance.

### Why Elasticsearch over Qdrant?

In Retrieval-Augmented Generation (RAG), there are 3 classic search methods:
* Lexical search with BM25 (TF-IDF)
* Semantic search with vector similarity
* Hybrid search combining both (using the Reciprocal Rank Fusion (RRF) algorithm to combine results)

We sought to offer these 3 search methods to our users. Initially, we implemented Qdrant for semantic search due to its scalability.

However, when wanting to add lexical and hybrid search, we found that Qdrant does not natively support these methods. [Their approach](https://qdrant.tech/documentation/concepts/inference/) is based on deploying a model alongside the vector store.

Additionally, Elasticsearch excels at lexical search with BM25 and natively enables complex filtering on specific fields. For these reasons, Elasticsearch seems like a better solution for RAG search.

OpenGateLLM's goal is to support multiple vector store solutions to give you the choice of the technology that best suits your needs.

## Major Changes

### End of Qdrant Support

To focus on Elasticsearch support, we have decided to deprecate Qdrant support. This decision was made after consulting the community on the subject. Indeed, it turns out that currently, no one has chosen Qdrant for their OpenGateLLM instance.

Additionally, with the OpenGateLLM team having limited resources, we cannot afford to maintain two vector store solutions at this time.

We do not rule out revisiting this decision in the future if the community requests it. Moreover, the goal remains to support multiple vector store solutions in the long term, once we have the necessary resources.

### Consolidation of Elasticsearch Indices into a Single Index

Currently, OpenGateLLM creates an Elasticsearch index for each collection. This approach allows collections to be managed independently. However, this is not optimal for scalability. Indeed, by default, Elasticsearch limits the number of shards (for each index, Elasticsearch creates at least one shard). The multiplication of indices can quickly become a performance bottleneck in this context.

>*A good rule-of-thumb is to ensure you keep the number of shards per node below 20 per GB heap it has configured. A node with a 30GB heap should therefore have a maximum of 600 shards, but the further below this limit you can keep it the better. [Source: How many shards should I have in my Elasticsearch cluster?](https://www.elastic.co/blog/how-many-shards-should-i-have-in-my-elasticsearch-cluster)*

To solve this problem, we decided to consolidate all Elasticsearch indices into a single index. To migrate your data, we provide a migration script (see [Migration Script](#migration-script)).

### Convert document metadata into a single field with constraints

Currently, when creating a document, users can define metadata for the document. They are free to define any metadata they want with the following types: `int`, `str`, `float`, `datetime`, or `bool`. Each metadata is stored in a separate field in the Elasticsearch index. This dynamic addition of metadata will quickly become problematic with the consolidation of indices into a single index. Indeed, Elasticsearch is not designed to optimally support thousands of fields on an index. This risks creating performance and scalability issues.

To address this issue, we decided to convert the metadata field into a single field of type `flattened`. However, this solution limits filtering actions on these fields (they are then stored in a single field and interpreted as `str`), see [Elasticsearch documentation](https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/flattened). However, the tests we have performed have shown that the filtering capabilities on a `flattened` field seem sufficient for RAG search operations.

Additionally, at the Pydantic level, we have added constraints on the types of data that can be stored in the metadata field.

From now on, the metadata field must comply with the following constraints:

```python
MIN_NUMBER, MAX_NUMBER = -9999999999999999, 9999999999999999

MetadataStr = Annotated[str, StringConstraints(strip_whitespace=True, min_length=1, max_length=255)]
MetadataInt = Annotated[int, Field(ge=MIN_NUMBER, le=MAX_NUMBER)]
MetadataFloat = Annotated[float, Field(ge=MIN_NUMBER, le=MAX_NUMBER)]
MetadataList = Annotated[list[MetadataStr | MetadataInt | MetadataFloat | bool | None], Field(max_length=8)]

ChunkMetadata = Annotated[dict[MetadataStr, MetadataStr | MetadataInt | MetadataFloat | MetadataList | bool | None], Field(description="Extra metadata for the source", min_length=1, max_length=8)]
```

One possible solution would have been to define fields with the `flattened` type. However, this solution only partially solves the performance problem and limits filtering actions on these fields (they are then stored in a single field and interpreted as `str`).

To ensure the scalability of the Elasticsearch index, we decided to pre-define metadata for documents. This approach avoids overloading the index with metadata while maintaining type-based filtering capabilities.

## Other Changes

### Fixes

* Fixed minor bugs in the Playground:
  * User expiration date formatting
  * Removal of the old collection ID type
  * Sorting and filters on Router and Provider pages
  * Removal of all roles and organizations for user creation

* Fixed support for the `language` parameter for audio transcription models with vLLM and Albert API so it can be empty. 
* The `collections` parameter in the search endpoint is now correctly typed as `list[int]`.

### Improvements

* Improved code readability for form data request declarations.
* Return of the `usage` key in stream responses from `/v1/chat/completions` even if the stream does not end with the `[DONE]` token.
* The `collections` parameter in the search endpoint now has a maximum length of 100 to avoid overwhelming the Elasticsearch index.
* `collection_id` and `document_id` have been moved to the chunk level. Previously, they were part of the chunk's metadata field, which could have led users to believe these values were editable.

## Migration Script

:::warning
The data migration will delete custom metadata from documents with there more than 8 fields.
:::

If you are running OpenGateLLM on an existing Elasticsearch instance, we invite you to use the migration script to migrate your data. Find the migration script in the [GitHub repository](https://github.com/etalab-ia/OpenGateLLM/blob/main/adr/2026-01-30-es-scaling.md#migration-script).
